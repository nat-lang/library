

domain R = {r1, r1};
domain A = {2,3,4,5};
domain B = {T, F};

let phi = (r) => {
  if (r == r1) return {2,3};
  if (r == r2) return {4,5};
};

let f1 = (n) => n / 2 == 0;
let f2 = (n) => 10 / n == 0;
let f3 = (n) => n < 4;

let node1 = (r) => ({f1(x) | x in phi(r)});
let node2 = (r) => ({f2(x) | x in phi(r)});
let node3 = (r) => ({f3(x) | x in phi(r)});

// hamblin application
let H_FA = (A, B) => (r) => ({a(b) | a in A(r), b in B(r)});

// roothian application
let R_FA = (A, B) => ({(g) => a(g)(b(g)) | a in A, b in B});

// denotational equivalence
assert(
  (((r) => f1) `H_FA` phi) == node1
);
assert(
  (((r) => f2) `H_FA` phi) == node2
);
assert(
  (((r) => f3) `H_FA` phi) == node3
);

let unaryGamma : (R -> {A}) -> {R -> A};
let unaryGamma = (node) => {
  let [r, body] <- node;

  return {\r => x | x in body};
};

let binaryGamma : (R -> {A}) -> (R -> {A}) -> {R -> A};
let binaryGamma = (a, b) => {
  let [rA, bodyA] <- a;
  let [rB, bodyB] <- b;

  assert(rA == rB, "`a` and `b` must bind the same variable.");

  return {\rA => bodyA(p(rA)) | p in G(b)};
};

let G = unaryGamma;
infix * = binaryGamma;

assert(
  G(((r) => f1) `HA` phi) == G((r) => f1) `RA` G(phi)
);




